<canvas id="myCanvas" width="800" height="600"></canvas>
<script>
  const canvas = document.getElementById('myCanvas');
  const ctx = canvas.getContext('2d');
  
  const width = canvas.width; 
  const height = canvas.height;
  
  // Ranges for the fractal visualization
  let realMin = -2.0;
  let realMax = 1.0;
  let imagMin = -1.2;
  let imagMax = 1.2;
  
  const maxIterations = 100;
  
  function calculateMandelbrot(cre, cim) {
    let zr = 0;
    let zi = 0;
    let i = 0;
  
    while (i < maxIterations) {
      const zrtemp = zr * zr - zi * zi + cre;
      zi = 2 * zr * zi + cim;
      zr = zrtemp;
  
      if (zr * zr + zi * zi > 4) {
        return i;
      }
      i++;
    }
  
    return -1; // Inside the Mandelbrot set 
  }
  
  function drawFractal() {
    const iterations = new Array(height);
    for (let y = 0; y < height; y++) {
      iterations[y] = new Array(width);
      for (let x = 0; x < width; x++) {
        // Map pixel coordinates to complex plane coordinates
        const cre = realMin + (x / width) * (realMax - realMin);
        const cim = imagMin + (y / height) * (imagMax - imagMin);
  
        iterations[y][x] = calculateMandelbrot(cre, cim);
      }
    }
    return iterations;
  }
  
  function render(iterations) {
    const canvas = document.getElementById('myCanvas'); 
    const ctx = canvas.getContext('2d');
  
    const maxIterations = iterations.reduce((max, row) => 
      Math.max(max, ...row), 0); // Find the overall max iterations
  
    for (let y = 0; y < iterations.length; y++) {
      for (let x = 0; x < iterations[y].length; x++) {
        const colorValue = iterations[y][x] / maxIterations;
  
        // Choose a color scheme:
        let color;
        if (iterations[y][x] === -1) {
          color = 'black';  // Inside the set
        } else {
          // Option 1: Grayscale
          // const brightness = Math.floor(255 * colorValue);
          // color = `rgb(${brightness}, ${brightness}, ${brightness})`;
  
          // Option 2: HSL Colors 
          color = `hsl(${colorValue * 360}, 100%, 50%)`;
        }
  
        ctx.fillStyle = color;
        ctx.fillRect(x, y, 1, 1);
      }
    }
  }
  
  function repaint() {
      const iterations = drawFractal(); 
      render(iterations); 
  }
  
  repaint();
  
  let isDragging = false;
  let startX, startY;
  
  canvas.addEventListener('mousedown', (event) => {
    isDragging = true;
    startX = event.clientX;
    startY = event.clientY;
  });
  
  canvas.addEventListener('mousemove', (event) => {
    if (isDragging) {
      const endX = event.clientX;
      const endY = event.clientY;
  
      const dx = (endX - startX) / width;  // Fractional offset in the real direction
      const dy = (endY - startY) / height; // Fractional offset in the imaginary direction
  
      const realWidth = realMax - realMin;
      const imagHeight = imagMax - imagMin;
  
      // Update the boundaries
      realMin -= dx * realWidth;
      realMax -= dx * realWidth;
      imagMin -= dy * imagHeight;
      imagMax -= dy * imagHeight;
  
      startX = endX;
      startY = endY;
  
      // Re-render the fractal with new boundaries
      repaint(); 
    }
  });
  
  canvas.addEventListener('mouseup', () => {
    isDragging = false;
  });
  
  const zoomFactor = 0.8; // Adjust this for zoom sensitivity
  
  canvas.addEventListener('wheel', (event) => {
    // Determine zoom direction (positive deltaY for zoom-in)
    const zoomDirection = -Math.sign(event.deltaY);
  
    // Get mouse position relative to the canvas
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;
  
    // Calculate the zoom center in complex plane coordinates
    const cre = realMin + (mouseX / width) * (realMax - realMin);
    const cim = imagMin + (mouseY / height) * (imagMax - imagMin); 
  
    // Calculate new boundaries 
    const realWidth = realMax - realMin;
    const imagHeight = imagMax - imagMin;
  
    if (zoomDirection > 0) { // Zoom-in
      realMin = cre - realWidth / 2 * zoomFactor;
      realMax = cre + realWidth / 2 * zoomFactor;
      imagMin = cim - imagHeight / 2 * zoomFactor;
      imagMax = cim + imagHeight / 2 * zoomFactor;
    } else { // Zoom-out
      realMin = cre - realWidth / 2 / zoomFactor;
      realMax = cre + realWidth / 2 / zoomFactor;
      imagMin = cim - imagHeight / 2 / zoomFactor;
      imagMax = cim + imagHeight / 2 / zoomFactor;
    }
  
    // Re-render the fractal
    const iterations = drawFractal();
    render(iterations);
  });
</script>
